#!/usr/bin/env bash
# Block tools unless /delegate was used, but ALWAYS allow delegation tools.
# Works even if the runner doesn't pass JSONâ€”keeps zero external deps.

set -euo pipefail

# --- DEBUG MODE (enable to troubleshoot) ---
# export DEBUG_DELEGATION_HOOK=1 to enable debug logging
DEBUG_HOOK="${DEBUG_DELEGATION_HOOK:-0}"
if [[ "$DEBUG_HOOK" == "1" ]]; then
  DEBUG_FILE="/tmp/claude_pretooluse_debug.log"
  {
    echo "=== Hook Invocation $(date) ==="
    echo "Arguments: $*"
    echo "Arg count: $#"
    echo "Arg 1: ${1:-<empty>}"
    echo "Arg 2: ${2:-<empty>}"
    echo "CLAUDE_TOOL_NAME: ${CLAUDE_TOOL_NAME:-<empty>}"
    echo "CLAUDE env vars:"
    env | grep -i claude || echo "  (none found)"
    echo "PWD: $PWD"
    echo "---"
  } >> "$DEBUG_FILE" 2>&1
fi

# --- quick bypass for emergencies ---
# export DELEGATION_HOOK_DISABLE=1  -> disables the hook
if [[ "${DELEGATION_HOOK_DISABLE:-0}" == "1" ]]; then
  [[ "$DEBUG_HOOK" == "1" ]] && echo "Hook disabled via DELEGATION_HOOK_DISABLE" >> "$DEBUG_FILE"
  exit 0
fi

# Tool name can arrive as $1 OR env (runner-dependent). Prefer $1 if present.
TOOL_NAME="${1:-${CLAUDE_TOOL_NAME:-}}"

[[ "$DEBUG_HOOK" == "1" ]] && echo "Detected TOOL_NAME: '$TOOL_NAME'" >> "$DEBUG_FILE"

# --- allowlist ---
# 1) Core safe tools (always allowed, even if tool name detection fails)
ALLOWED_TOOLS=(
  "AskUserQuestion"
  "TodoWrite"
  "SlashCommand"   # keep this to allow /delegate
  "Task"           # allow delegation Task tool
  "SubagentTask"   # common variant names, harmless to include
  "AgentTask"
)

# 2) Check allowlist FIRST (before blocking on unknown names)
#    This ensures allowlisted tools work even if tool name detection is broken
shopt -s nocasematch

if [[ -n "$TOOL_NAME" ]]; then
  # Exact allowlist check
  for t in "${ALLOWED_TOOLS[@]}"; do
    if [[ "$TOOL_NAME" == "$t" ]]; then
      [[ "$DEBUG_HOOK" == "1" ]] && echo "ALLOWED: Matched allowlist entry '$t'" >> "$DEBUG_FILE"
      exit 0
    fi
  done

  # Pattern allow (e.g., "Delegate", "DelegationManager", "Task.Delegate", etc.)
  if [[ "$TOOL_NAME" == *delegate* || "$TOOL_NAME" == *delegation* || "$TOOL_NAME" == Task.* ]]; then
    [[ "$DEBUG_HOOK" == "1" ]] && echo "ALLOWED: Matched delegation pattern" >> "$DEBUG_FILE"
    exit 0
  fi
fi

shopt -u nocasematch

# 3) If tool name is unknown, block (fail closed for security)
if [[ -z "$TOOL_NAME" ]]; then
  [[ "$DEBUG_HOOK" == "1" ]] && echo "BLOCKED: Unknown tool name" >> "$DEBUG_FILE"
  {
    echo "ðŸš« Tool blocked by delegation policy"
    echo "Tool: <unknown>"
    echo "Reason: Tool name could not be determined"
    echo "Hint: export DEBUG_DELEGATION_HOOK=1 to debug"
    echo "Run: /delegate <task>  (then retry)"
  } >&2
  exit 2
fi

# --- one-shot delegation flag (created by your /delegate command) ---
STATE_DIR="${CLAUDE_PROJECT_DIR:-$PWD}/.claude/state"
FLAG_FILE="$STATE_DIR/delegated.once"

if [[ -f "$FLAG_FILE" ]]; then
  rm -f -- "$FLAG_FILE" || true   # consume the allowance
  exit 0
fi

# --- block (deny) all other tools until /delegate is used ---
[[ "$DEBUG_HOOK" == "1" ]] && echo "BLOCKED: Tool '$TOOL_NAME' not allowlisted or delegated" >> "$DEBUG_FILE"
{
  echo "ðŸš« Tool blocked by delegation policy"
  echo "Tool: $TOOL_NAME"
  echo "Run: /delegate <task>  (then retry)"
} >&2
exit 2
